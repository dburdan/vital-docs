---
sidebar_position: 1
---

import { Image } from "@chakra-ui/react";

# iOS

## 1. Introduction

The iOS SDK is split into three main components: VitalCore, VitalHealthKit and VitalDevices. VitalCore holds common components to both VitalHealthKit and VitalDevices. Among other things, it has the network layer that allows us to send data from a device to a server. As their name hint, VitalHealthKit and VitalDevices are an abstraction over HealthKit and specific Bluetooth devices. If your app is generating data independently, you can use VitalCore directly to push data.

---

## 2. Installation

We use SPM (Swift Package Manager) to manage dependencies. You can add `https://github.com/tryVital/vital-ios` when adding it as a dependency to your project. Independently of using VitalDevices, or VitalHealthKit, make sure you always add VitalCore. The first two depend on the latter.

<iframe
  src="https://www.loom.com/embed/fa091653aab24feeb52253a584c69512"
  frameborder="0"
  allowfullscreen="true"
  width="100%"
  height="533"
>
  {" "}
</iframe>

## 3. Initial Setup

To use our SDK, start by setting up `VitalClient`:

```swift
import VitalCore

VitalClient.configure(
    apiKey: "xyz",
    environment: .sandbox(.us)
)
```

<br />

There are two main topics you should be aware:

1. `userId`.
2. Connected source.

### 1. `userId`

A `userId` serves as a unique identifier of your user in Vital. You create one by sending us an id representing that user in your system (e.g. `white_bear`, `12832001`, `b5d36dbe-b745-11ec-b909-0242ac120002`, etc). We advise against the use of PII (Personal Identifiable Information). It should also be unique across the users that belong to your team. You can create a `userId` like this:

```swift
let result = try await VitalClient.shared.user.create(
    .init(clientUserId: "white_bear"),
    setUserIdOnSuccess: false
)
```

<br />

A `userId` is an `UUID4`. Once you have a `userId`, you need to set it:

```swift
VitalClient.setUserId(result.userId)
```

<br />

:::tip

By default, when you create a `userId`, we call `VitalClient.setUserId` internally. If you don't want this to happen call `VitalClient.setUserId(result.userId, setUserIdOnSuccess: false)`.

:::

### 2. Connected Source

A connected source is a link between a provider (e.g. Omron) and your user. When you post information, it is expected that a connected source exists for that user and the source of information you are using. If it doesn't exist, the request will fail.

Example: You want to post Ben's Omron data to Vital. Two things need to exist: 1) Ben is a user in Vital 2) A connected source linking Ben's user to Omron.

To achieve this you can:

```swift

/// 1)
let benUser = try await VitalClient.shared.user.create(clientUserId: "white_bear")

/// 2)
let result = try await VitalClient.shared.user.createConnectedSource(for: .omron)
```

<br />

With these two things in place, you can now post Ben's Omron data.

---

## 4. VitalCore

For the most part, you won't need to instantiate model objects. VitalHealthKit and VitalDevices will generate these models on your behalf. For VitalDevices in particular, you are responsible for sending the data explicitly via `VitalClient.shared.<domain>`. VitalClient allows you to do exactly that. VitalHealkit however will send the data automatically.

### 1. TimeSeries and Summaries

There are two main sources of data: time series and summaries. Time series data correspond to points in time (e.g. glucose, heart rate, etc). Summaries are a digest of a particular activity (e.g. workout, sleep, etc). Summaries can have time series data. For example an workout has an array of heart rate data points. For data generated by VitalDevices, typically this will be time series.

For time series we support:

- Glucose
- Blood Pressure

For summaries:

- Workout
- Activity
- Sleep
- Profile
- Body

Posting time series data is as simple as:

```swift
let sample = QuantitySample(
    value: 10,
    startDate: .init(),
    endDate: .init(),
    type: "fingerprick",
    unit: "mg/dl"
)

let samples: [BloodPressureSample] = [sample]

try await VitalClient.shared.timeSeries.post(
    .bloodPressure(samples),
    stage: .daily,
    provider: .appleHealthKit
)
```

<br />

Likewise for summaries:

```swift
let workoutPatch: WorkoutPatch = ...

try await VitalClient.shared.summary.post(
    .workout(workoutPatch),
    stage: .daily,
    provider: .appleHealthKit
)
```

<br />

It's important to notice a few things in the above snippet:

1. We set the stage of data as `.daily`. If you are sending old data, please use `.historical` instead. This distinction is used for the Webhooks. If you are not sure if `.historical` data makes sense, you can stick with `.daily`. A `.daily` will always generate a webhook with the full payload of data. For more information, please read the [Webhook Flow](/webhooks/data_flow).
2. The provider (`.appleHealthKit`) must match an existing connected source for that user. This means that if there's no connected source linking the user and `.appleHealthKit`, the request will fail.
3. Finally if you are generating your own fitness or medical data, use the `.manual` provider.

### 2. Creating a Connected Source

The SDK provides two ways to create a connected source. The first method is a manual approach. This is the method you should use for HealthKit, Manual and bluethooth devices.

```swift
let userId: UUID = ...

VitalClient.shared.link.createConnectedSource(userId, provider: .appleHealthKit)
```

<br />

The second method uses web authentication:

```swift
let url = try await VitalClient.shared.link.createProviderLink(redirectURL: "vitalExample://")
```

<br />

The `redirectURL` is the URL that's called after the authentication is done. For an iOS app, you add the following to your Info.plist:

<Image src="/img/iOS/plist_url_identifier.jpg" />

<br />

After having the `url`, you can open it with `SFSafariViewController` or `WKWebView`. On completion, your app will be called with an URL with the following shape:

1. On success: `vitalExample://?state=success&isMobile=true&provider=<provider>`.
2. On failure: `vitalExample://?state=error&isMobile=true&provider=<provider>&error=<error description>`.

---

## 5. VitalDevices

### 1. Bluetooth

VitalDevices connects your app to other devices via bluetooth. Currently we support glucose meters and blood pressure readers.

You start by fetching all devices supported:

```swift
import VitalDevices

/// Get the brands
let brands = DevicesManager.brands()

/// Each brand has devices
let devices = DevicesManager.devices(for: brands[0])
```

<br />

Based on the `device`, you start scanning your surroundings to find it. This approach filters out devices we are not interested in:

```swift
let device = devices[0]

let manager = DevicesManager()
let publisher: AnyPublisher<ScannedDevice, Never> = manager.search(for: device)
```

<br />

You can observe the publisher (e.g. via `sink`) until you find a device. Once you find a device you create a reader:

```swift
let scannedDevice: ScannedDevice = ...

if scannedDevice.kind == .bloodPressure {
    let reader: BloodPressureReadable = manager.bloodPressureReader(for: scannedDevice)
}

if scannedDevice.kind == .glucoseMeter {
    let reader: GlucoseMeterReadable = manager.glucoseMeter(for: scannedDevice)
}
```

<br />

Depending on the flow of your app, and/or the device you are working with, you can either just pair, or pair and read. The "just" pair is needed for devices that can only pair while in pairing mode. The devices we tested were able to pair and read while not in pairing mode, but your experience might be different.

For blood pressure monitors:

```swift
let reader: BloodPressureReadable = manager.bloodPressureReader(for: scannedDevice)

let justPair: AnyPublisher<Void, Error> = reader.pair(device: scannedDevice)
let pairAndRead: AnyPublisher<[BloodPressureSample], Error> = reader.read(device: scannedDevice)
```

<br />

And for glucose meters:

```swift
let reader: GlucoseMeterReadable = manager.glucoseMeter(for: scannedDevice)

let justPair: AnyPublisher<Void, Error> = reader.pair(device: scannedDevice)
let pairAndRead: AnyPublisher<[QuantitySample], Error> = reader.read(device: scannedDevice)
```

<br />

You can monitor the connection to the device via:

```swift
let monitorDevice: AnyPublisher<Bool, Never> = manager.monitorConnection(for: device)
```

<br />

:::caution
When you finish scanning for a device, you need to terminate the scanning. If you don't do this, you won't be able to connect and extract data from the device. You can achieve this by holding onto a `Cancellable` (via `sink`) and call `cancel()`. Or by using a more declarative approach (e.g. `publisher.first()`).

You can check our example app, to see how we do it.
:::

### 2. Freestyle Libre 1

We currently support Libre 1 sensors via NFC readings. Please make sure you add NFC capabilities in your app:

<Image src="/img/iOS/nfc_permission.png" />

<br />

Also add the key `NFCReaderUsageDescription` in your info.plist. This key should explain why your app needs to use NFC.

To use the reader:

```swift
let reader = Libre1Reader(
        readingMessage: "Ready for reading",
        errorMessage: "Failed reading from sensor",
        completionMessage: "Completed successfully!",
        queue: mainQueue
    )


let reading = try await reader.read()
```

<br />

A `reading` is a payload with two properties: 1) the sensor information 2) an array of glucose readings.

```swift

let sensor: Libre1Sensor = reading.sensor
let samples: [QuantitySample] = reading.samples
```

<br />

As previously mentioned, you are responsible for sending the samples to the server. You can do so via `VitalNetworkClient.shared.timeSeries.post`.

:::caution
Readings taken with the SDK are not guaranteed to match the official Freestyle Libre app. This mismatch happens due to the algorithm difference used by us, compared to the official Freestyle Libre.
:::

---

## 6. VitalHealthKit

VitalHealthKit is an abstraction on top of HealthKit that 1) automates the extraction of data 2) pushs that data to Vital automatically.

You start by enabling HealthKit capabilities in your app. Please follow this [guide](https://developer.apple.com/documentation/healthkit/setting_up_healthkit). It should looks like this:

<Image src="/img/iOS/health_kit_permission.png" />

<br />

You then set-up the client:

```swift
import VitalHealthKit

VitalHealthKitClient.configure(
    .init(
        autoSyncEnabled: ..., // false by default
        backgroundDeliveryEnabled: ..., // false by default
        logsEnabled: ..., // false by default
        daysFetched: ..., // 90 by default
    )
)
```

<br />

That's it!

Just like VitalDevices, you need to configure the `VitalClient` at some point during your flow.

:::info
When configuring `VitalHealthKitClient`, you can enable logs, background delivery, number of days you want to backfill and `auto-sync`. The latter in particular, will immediately try to push data, once the `configuration` method is called.
:::

:::caution
Be aware that you need to setup `VitalClient` in order for data to be pushed. The `VitalHealthKitClient` is suspended until both `VitalClient.configure` and `VitalClient.setUserId` are called. This means that it's safe to configure `VitalHealthKitClient` before the `VitalClient`.
:::

After this initial setup, you need to ask permission to acccess the user's data:

```swift
let resources = [.profile, .body]
let outcome = await VitalHealthKitClient.shared.ask(for: resources)
```

<br />

After calling `ask(for:)`, check the `outcome` to see if the user granted permission. On success, you can start syncing data:

```swift
import VitalHealthKit

let resources = [.profile, .body]
VitalHealthKitClient.shared.syncData(for: resources)


/// You can also sync all resources
VitalHealthKitClient.shared.syncData()
```

<br />

:::caution
Everything that holds true for HealthKit, holds true for `VitalHealthKit`. For example, if someone declines to give permission to a particular type, the SDK won't be aware. For more information please read [HealthKit's Protecting User Privacy](https://developer.apple.com/documentation/healthkit/protecting_user_privacy).
:::

Although `syncData()` and `syncData(for:)` make your life easier, they can sometimes feel like a blackbox. To help you understand what's happening under the hood, we expose an `status: AnyPublisher<Status, Never>`. A `Status` looks like this:

```swift
  public enum Status {
    case syncing(VitalResource)
    case failedSyncing(VitalResource, Error?)
    case successSyncing(VitalResource)
    case nothingToSync(VitalResource)
  }
```

<br />

You can observe and convey this information to your user like this:

```swift
cancellable = VitalHealthKitClient.shared.status.sink { value in
    print(value)
}
```

### 1. Background Delivery

You can enable the SDK to deliver HealthKit data in background. This provides a more seamless experience, since the user doesn't need to open your app to sync data. Start by enabling "Background Delivery" in the app capabilities:

<Image src="/img/iOS/health_kit_permission_background_delivery.png" />

Once this is done, you should setup the SDK like so:

```swift
import VitalHealthKit

VitalHealthKitClient.configure(
    .init(backgroundDeliveryEnabled: true)
)
```

<br />

That's the only thing you need to do! If you are using background delivery, you also don't need to call `syncData:`. Depending on the `HKSampleType` syncing, updates will come after a period of time.

<br />

:::caution
As per the [documentation](https://developer.apple.com/documentation/healthkit/hkhealthstore/1614175-enablebackgrounddelivery):

> As soon as your app launches, HealthKit calls the update handler for any observer queries that match the newly saved data. If you plan on supporting background delivery, set up all your observer queries in your app delegate’s application(_:didFinishLaunchingWithOptions:) method. By setting up the queries in application(_:didFinishLaunchingWithOptions:), you ensure that you’ve instantiated your queries, and they’re ready to use before HealthKit delivers the updates.

This means that you should make sure you call `VitalHealthKitClient.configure(.init(backgroundDeliveryEnabled: true))` in your app delegate's `application(_:didFinishLaunchingWithOptions:)` method.
:::

:::caution
As per the [documentation](https://developer.apple.com/documentation/healthkit/hkhealthstore/1614175-enablebackgrounddelivery):

> HealthKit wakes your app whenever a process saves or deletes samples of the specified type. The system wakes your app at most once per time period defined by the specified frequency. Some sample types have a maximum frequency of `HKUpdateFrequency.hourly`. The system enforces this frequency transparently.
>
> For example, on iOS, `stepCount` samples have an hourly maximum frequency.

This means that although we have background delivery's frequency set to `.immediate`, we cannot guarantee immediate syncing.
:::
