---
title: "iOS"
---

## 1. Introduction

The iOS SDK is split into three main components: VitalCore, VitalHealthKit and VitalDevices. VitalCore holds common components to both VitalHealthKit and VitalDevices. Among other things, it has the network layer that allows us to send data from a device to a server. As their name hint, VitalHealthKit and VitalDevices are an abstraction over HealthKit and specific Bluetooth devices. If your app is generating data independently, you can use VitalCore directly to push data.

## 2. Installation

We use SPM (Swift Package Manager) to manage dependencies. You can add `https://github.com/tryVital/vital-ios` when adding it as a dependency to your project. Independently of using VitalDevices, or VitalHealthKit, make sure you always add VitalCore. The first two depend on the latter.

<iframe
  src="https://www.loom.com/embed/fa091653aab24feeb52253a584c69512"
  frameborder="0"
  allowfullscreen="true"
  width="100%"
  height="533"
>
  {" "}
</iframe>

## 3. Initial Setup

To use our SDK, start by setting up `VitalClient`:

```swift
import VitalCore

await VitalClient.configure(
    apiKey: "xyz",
    environment: .sandbox(.us)
)
```

There are two main topics you should be aware:

1. `userId`.
2. Connected source.

### 1. `userId`

A `userId` serves as a unique identifier of your user in Vital. You create one by sending us an id representing that user in your system (e.g. `white_bear`, `12832001`, `b5d36dbe-b745-11ec-b909-0242ac120002`, etc). We advise against the use of PII (Personal Identifiable Information). It should also be unique across the users that belong to your team. You can create a `userId` like this:

```swift
let result = try await VitalClient.shared.user.create(
    .init(clientUserId: "white_bear"),
    setUserIdOnSuccess: false
)
```

A `userId` is an `UUID4`. Once you have a `userId`, you need to set it:

```swift
await VitalClient.setUserId(result.userId)
```

<Tip>

By default, when you create a `userId`, we call `VitalClient.setUserId` internally. If you don't want this to happen call `VitalClient.setUserId(result.userId, setUserIdOnSuccess: false)`.

</Tip>

### 2. Connected Source

A connected source is a link between a provider (e.g. Omron) and your user. When you post information, it is expected that a connected source exists for that user and the source of information you are using. If it doesn't exist, the request will fail.

Example: You want to post Ben's Omron data to Vital. Two things need to exist: 1) Ben is a user in Vital 2) A connected source linking Ben's user to Omron.

To achieve this you can:

```swift

/// 1)
let benUser = try await VitalClient.shared.user.create(clientUserId: "white_bear")

/// 2)
let result = try await VitalClient.shared.user.createConnectedSource(for: .omron)
```

With these two things in place, you can now post Ben's Omron data.

## 4. VitalCore

For the most part, you won't need to instantiate model objects. VitalHealthKit and VitalDevices will generate these models on your behalf. For VitalDevices in particular, you are responsible for sending the data explicitly via `VitalClient.shared.<domain>`. VitalClient allows you to do exactly that. VitalHealkit however will send the data automatically.

### 1. TimeSeries and Summaries

There are two main sources of data: time series and summaries. Time series data correspond to points in time (e.g. glucose, heart rate, etc). Summaries are a digest of a particular activity (e.g. workout, sleep, etc). Summaries can have time series data. For example an workout has an array of heart rate data points. For data generated by VitalDevices, typically this will be time series.

For time series we support:

- Glucose
- Blood Pressure

For summaries:

- Workout
- Activity
- Sleep
- Profile
- Body

Posting time series data is as simple as:

```swift
let sample = QuantitySample(
    value: 10,
    startDate: .init(),
    endDate: .init(),
    type: "fingerprick",
    unit: "mg/dl"
)

let samples: [BloodPressureSample] = [sample]

try await VitalClient.shared.timeSeries.post(
    .bloodPressure(samples),
    stage: .daily,
    provider: .appleHealthKit
)
```

Likewise for summaries:

```swift
let workoutPatch: WorkoutPatch = ...

try await VitalClient.shared.summary.post(
    .workout(workoutPatch),
    stage: .daily,
    provider: .appleHealthKit
)
```

It's important to notice a few things in the above snippet:

1. We set the stage of data as `.daily`. If you are sending old data, please use `.historical` instead. This distinction is used for the Webhooks. If you are not sure if `.historical` data makes sense, you can stick with `.daily`. A `.daily` will always generate a webhook with the full payload of data. For more information, please read the [Webhook Flow](/webhooks/data_flow).
2. The provider (`.appleHealthKit`) must match an existing connected source for that user. This means that if there's no connected source linking the user and `.appleHealthKit`, the request will fail.
3. Finally if you are generating your own fitness or medical data, use the `.manual` provider.

### 2. Creating a Connected Source

The SDK provides two ways to create a connected source. The first method is a manual approach. This is the method you should use for HealthKit, Manual and bluethooth devices.

```swift
let userId: UUID = ...

try await VitalClient.shared.link.createConnectedSource(userId, provider: .appleHealthKit)
```

The second method uses web authentication:

```swift
let url = try await VitalClient.shared.link.createProviderLink(redirectURL: "vitalExample://")
```

The `redirectURL` is the URL that's called after the authentication is done. For an iOS app, you add the following to your Info.plist:

<img src="/img/iOS/plist_url_identifier.jpg" />

After having the `url`, you can open it with `SFSafariViewController` or `WKWebView`. On completion, your app will be called with an URL with the following shape:

1. On success: `vitalExample://?state=success&isMobile=true&provider=<provider>`.
2. On failure: `vitalExample://?state=error&isMobile=true&provider=<provider>&error=<error description>`.

## 5. VitalDevices

### 1. Bluetooth

VitalDevices connects your app to other devices via bluetooth. Currently we support glucose meters and blood pressure readers.

You start by fetching all devices supported:

```swift
import VitalDevices

/// Get the brands
let brands = DevicesManager.brands()

/// Each brand has devices
let devices = DevicesManager.devices(for: brands[0])
```

Based on the `device`, you start scanning your surroundings to find it. This approach filters out devices we are not interested in:

```swift
let device = devices[0]

let manager = DevicesManager()
let publisher: AnyPublisher<ScannedDevice, Never> = manager.search(for: device)
```

You can observe the publisher (e.g. via `sink`) until you find a device. Once you find a device you create a reader:

```swift
let scannedDevice: ScannedDevice = ...

if scannedDevice.kind == .bloodPressure {
    let reader: BloodPressureReadable = manager.bloodPressureReader(for: scannedDevice)
}

if scannedDevice.kind == .glucoseMeter {
    let reader: GlucoseMeterReadable = manager.glucoseMeter(for: scannedDevice)
}
```

Depending on the flow of your app, and/or the device you are working with, you can either just pair, or pair and read. The "just" pair is needed for devices that can only pair while in pairing mode. The devices we tested were able to pair and read while not in pairing mode, but your experience might be different.

For blood pressure monitors:

```swift
let reader: BloodPressureReadable = manager.bloodPressureReader(for: scannedDevice)

let justPair: AnyPublisher<Void, Error> = reader.pair(device: scannedDevice)
let pairAndRead: AnyPublisher<[BloodPressureSample], Error> = reader.read(device: scannedDevice)
```

And for glucose meters:

```swift
let reader: GlucoseMeterReadable = manager.glucoseMeter(for: scannedDevice)

let justPair: AnyPublisher<Void, Error> = reader.pair(device: scannedDevice)
let pairAndRead: AnyPublisher<[QuantitySample], Error> = reader.read(device: scannedDevice)
```

You can monitor the connection to the device via:

```swift
let monitorDevice: AnyPublisher<Bool, Never> = manager.monitorConnection(for: device)
```

<Warning>

When you finish scanning for a device, you need to terminate the scanning. If you don't do this, you won't be able to connect and extract data from the device. You can achieve this by holding onto a `Cancellable` (via `sink`) and call `cancel()`. Or by using a more declarative approach (e.g. `publisher.first()`).

You can check our example app, to see how we do it.

</Warning>

### 2. Freestyle Libre 1

We currently support Libre 1 sensors via NFC readings. Please make sure you add NFC capabilities in your app:

<img src="/img/iOS/nfc_permission.png" />

Also add the key `NFCReaderUsageDescription` in your info.plist. This key should explain why your app needs to use NFC.

To use the reader:

```swift
let reader = Libre1Reader(
        readingMessage: "Ready for reading",
        errorMessage: "Failed reading from sensor",
        completionMessage: "Completed successfully!",
        queue: mainQueue
    )


let reading = try await reader.read()
```

A `reading` is a payload with two properties: 1) the sensor information 2) an array of glucose readings.

```swift

let sensor: Libre1Sensor = reading.sensor
let samples: [QuantitySample] = reading.samples
```

As previously mentioned, you are responsible for sending the samples to the server. You can do so via `VitalNetworkClient.shared.timeSeries.post`.

<Warning>
  Readings taken with the SDK are not guaranteed to match the official Freestyle
  Libre app. This mismatch happens due to the algorithm difference used by us,
  compared to the official Freestyle Libre.
</Warning>

---

## 6. VitalHealthKit

### 1. Quick Intro

VitalHealthKit is an abstraction on top of HealthKit that **1)** automates the extraction of data **2)** pushs that data to Vital automatically.

You start by enabling HealthKit capabilities in your app. Please follow this [guide](https://developer.apple.com/documentation/healthkit/setting_up_healthkit). It should looks like this:

<img src="/img/iOS/health_kit_permission.png" />

You then set-up the client:

```swift
import VitalHealthKit

await VitalHealthKitClient.configure(
    .init(
        mode: ..., // automatic by default
        backgroundDeliveryEnabled: ..., // false by default
        logsEnabled: ..., // false by default
        numberOfDaysToBackFill: ..., // 90 by default
    )
)
```

That's it!

Just like VitalDevices, you need to configure the `VitalClient` at some point during your flow. Like this:

```swift
import VitalCore

await VitalClient.configure(
    apiKey: "xyz",
    environment: .sandbox(.us)
)

await VitalClient.setUserId(result.userId)
```

<Note>
VitalHealthKit will check if the `userId` has an associted Apple HealthKit connected source. If it doesn't, it will create one automatically. This means that you don't need to do this:

```swift
let result = try await VitalClient.shared.user.createConnectedSource(for: .omron)
```

</Note>

<Note>

When configuring `VitalHealthKitClient`, you can enable logs, background delivery, number of days you want to backfill and mode. The latter in particular, specifies if you want to be responsible for pushing data youself, or allow the SDK to do that on your behalf. By default the SDK is set to automatic.

</Note>

<Warning>

Be aware that you need to setup `VitalClient` in order for data to be pushed. The `VitalHealthKitClient` is suspended until both `VitalClient.configure` and `VitalClient.setUserId` are called. This means that it's safe to configure `VitalHealthKitClient` before the `VitalClient`.

</Warning>

After this initial setup, you need to ask permission to acccess the user's data:

```swift
let resources = [.profile, .body]
let outcome = await VitalHealthKitClient.shared.ask(for: resources)
```

After calling `ask(for:)`, check the `outcome` to see if the user granted permission. On success, you can start syncing data:

```swift
import VitalHealthKit

let resources = [.profile, .body]
VitalHealthKitClient.shared.syncData(for: resources)


/// You can also sync all resources
VitalHealthKitClient.shared.syncData()
```

<Warning>

Everything that holds true for HealthKit, holds true for `VitalHealthKit`. For example, if someone declines to give permission to a particular type, the SDK won't be aware. For more information please read [HealthKit's Protecting User Privacy](https://developer.apple.com/documentation/healthkit/protecting_user_privacy).

</Warning>

Although `syncData()` and `syncData(for:)` make your life easier, they can sometimes feel like a blackbox. To help you understand what's happening under the hood, we expose an `status: AnyPublisher<Status, Never>`. A `Status` looks like this:

```swift
  public enum Status {
    case failedSyncing(VitalResource, Error?)
    case successSyncing(VitalResource, ProcessedResourceData)
    case nothingToSync(VitalResource)
    case syncing(VitalResource)
    case syncingCompleted
  }
```

You can observe and convey this information like this:

```swift
cancellable = VitalHealthKitClient.shared.status.sink { value in
    print(value)
}
```

### 2. Background Delivery

You can enable the SDK to deliver HealthKit data in background. This provides a more seamless experience, since the user doesn't need to open your app to sync data. Start by enabling "Background Delivery" in the app capabilities:

<img src="/img/iOS/health_kit_permission_background_delivery.png" />

Once this is done, you should setup the SDK like so:

```swift
import VitalHealthKit

VitalHealthKitClient.configure(backgroundDeliveryEnabled: true)
```

That's the only thing you need to do! If you are using background delivery, you don't need to call `syncData:`. Depending on the `HKSampleType` syncing, updates will come after a period of time.

<Warning>

As per the [documentation](https://developer.apple.com/documentation/healthkit/hkhealthstore/1614175-enablebackgrounddelivery):

> As soon as your app launches, HealthKit calls the update handler for any observer queries that match the newly saved data. If you plan on supporting background delivery, set up all your observer queries in your app delegate’s application(_:didFinishLaunchingWithOptions:) method. By setting up the queries in `application(_:didFinishLaunchingWithOptions:)`, you ensure that you’ve instantiated your queries, and they’re ready to use before HealthKit delivers the updates.

This means that you should make sure you call `VitalHealthKitClient.configure(.init(backgroundDeliveryEnabled: true))` in your app delegate's `application(_:didFinishLaunchingWithOptions:)` method.

</Warning>

<Warning>

As per the [documentation](https://developer.apple.com/documentation/healthkit/hkhealthstore/1614175-enablebackgrounddelivery):

> HealthKit wakes your app whenever a process saves or deletes samples of the specified type. The system wakes your app at most once per time period defined by the specified frequency. Some sample types have a maximum frequency of `HKUpdateFrequency.hourly`. The system enforces this frequency transparently.
>
> For example, on iOS, `stepCount` samples have an hourly maximum frequency.

This means that although we have background delivery's frequency set to `.hourly`, we cannot guarantee hourly syncing on the dot.

</Warning>

### 3. Miscellaneous Information

#### SDK configuration flow

Vital's iOS SDK allows you to configure it in any order you wish. There are however two things to keep in mind:

1. You need to call `VitalClient.configure`, `VitalClient.setUserId` and `VitalHealthKitClient.configure` in order for data to be pushed to Vital.
2. You need to call `VitalHealthKitClient.configure` at `application(_:didFinishLaunchingWithOptions:)`, in order for background delivery to work properly.

From an implementation perspective, `VitalHealthKitClient` suspends all operations until both `VitalClient.configure` and `VitalClient.setUserId` are called. This means that it's safe to configure `VitalHealthKitClient` before the `VitalClient`.

#### VitalHealthKit configuration

The `VitalHealthKitClient` can be configured with the following options:

- `mode`: Whether or not to automatically sync data. If in `automatic`, data is synced on your behalf. Otherwise, you are responsible for doing so. By default, this is `automatic`.
- `backgroundDeliveryEnabled`: Whether or not to enable background delivery. You need to enable this on the project settings besides passing `true`, otherwise the app will crash. If `true` as soon as configure is called, a sync is kicked off by default. This means you don't need both `autoSyncEnabled` and `backgroundDeliveryEnabled` set to `true`. By default, this is `false`.
- `logsEnabled`: Whether or not to enable logs. Useful when debugging. By default, this is `false`.
- `numberOfDaysToBackFill`: Number of days to fetch data for. The first you configure the SDK, we will get X days of amount of data for the permissions you requested. By default, this is `90`.

#### `sync` versus background delivery

If you are using background delivery, you don't need to call `VitalHealthKit.shared.sync`. When you call `VitalHealthKit.configure` with `backgroundDeliveryEnabled: true`, the SDK will automatically sync data. Afterwards, it will periodically sync data when it's available. You should call `VitalHealthKit.shared.sync` if you are confident that there's new data available (e.g. your app is writting to HealthKit) and you want to sync immediately.

#### App with existing HealthKit permissions

As of version `0.4.6` we are syncing the following types:

```swift
/// Activity
HKSampleType.quantityType(forIdentifier: .stepCount)!,
HKSampleType.quantityType(forIdentifier: .activeEnergyBurned)!,
HKSampleType.quantityType(forIdentifier: .basalEnergyBurned)!,
HKSampleType.quantityType(forIdentifier: .flightsClimbed)!,
HKSampleType.quantityType(forIdentifier: .distanceWalkingRunning)!,
HKSampleType.quantityType(forIdentifier: .vo2Max)!,
HKSampleType.quantityType(forIdentifier: .bodyMass)!,

/// Body
HKSampleType.quantityType(forIdentifier: .bodyFatPercentage)!,
HKQuantityType.quantityType(forIdentifier: .height)!,

/// Profile
HKCharacteristicType.characteristicType(forIdentifier: .biologicalSex)!,
HKCharacteristicType.characteristicType(forIdentifier: .dateOfBirth)!,

/// Sleep
HKSampleType.categoryType(forIdentifier: .sleepAnalysis)!,
HKSampleType.quantityType(forIdentifier: .heartRate)!,
HKSampleType.quantityType(forIdentifier: .heartRateVariabilitySDNN)!,
HKSampleType.quantityType(forIdentifier: .oxygenSaturation)!,
HKSampleType.quantityType(forIdentifier: .restingHeartRate)!,
HKSampleType.quantityType(forIdentifier: .respiratoryRate)!

/// Workout
HKSampleType.workoutType(),
HKSampleType.quantityType(forIdentifier: .respiratoryRate)!
HKSampleType.quantityType(forIdentifier: .heartRate)!,

/// Vitals(Heartrate)
HKSampleType.quantityType(forIdentifier: .heartRate)!,

/// Vitals(glucose)
HKSampleType.quantityType(forIdentifier: .bloodGlucose)!

/// Vitals(blood pressure)
HKSampleType.quantityType(forIdentifier: .bloodPressureSystolic)!,
HKSampleType.quantityType(forIdentifier: .bloodPressureDiastolic)!
```

If your app already asked for one, or more, of these permissions, we will try to sync it automatically. You don't have to do anything. Keep in mind the following caveats:

1. For example, if the user gave permission for steps, we will try sync steps as part of an Activity. This means that this data is available via `/summary/activity/` endpoint.
2. Types part of `Vitals` (e.g. `heartrate`, `bloodGlucose`), are treated as timeseries data, so they are available via the timeseries API: `/timeseries/`.

#### Information flow

For the majority of users, the SDK is configured with background delivery to true. Data is synced on their behalf and they don't need to think about it. Eventually, to display the information back to their users, they make an HTTP request to a server. This means that information flows looks like this:

```
Apple HealthKit -> SDK -> Vital Server -> Your Server <- User's app
```

You can bypass the above flow, by using `VitalHealthKit.read`. This is a static method that doesn't require the SDK to be configured. This is a good option for users that are only dealing Apple HealthKit data and they want data immediately. You can still keep background delivery enabled, but read from Apple HealthKit directly.

<Note>

If your user is sharing Apple HealthKit data and some other provider, we do recommend you reading the data from the server. Finally even if it's only Apple HealthKit, we do extra calculations on the server side (e.g. sleep effiency). If you use `VitalHealthKit.read` you will miss these values.

</Note>
